#!/usr/bin/env bash
#
# Argbash definitions for ZenCash Tracker control script ztc
#
# ARG_OPTIONAL_BOOLEAN([wait],[w],[Wait for requested operation to complete])
# ARG_POSITIONAL_SINGLE([verb],[Script action: start,stop,restart,chal/challenge,cfg/configure,info,status],[])
# ARG_POSITIONAL_INF([parms],[Additional parameters for configure],[])
# ARG_HELP([ZenCash Tracker control script zct
# -w, --wait to follow log until completion
# start: start  zend + zentracker
# stop : stop   zend + zentracker
# restart: stop + (?wait?) + start
# chal/challenge: request challenge
# configure/cfg: set up for type/region/stake
# info: extract addresses, balances, keys for backup & scripting
# status: services up/down, exception if any, challenge balance
# ])
# ARG_VERSION([echo $0 v0.1])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='whv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_parms=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_wait="off"

print_help ()
{
  printf '%s\n' "ZenCash Tracker control script zct
# -w, --wait to follow log until completion
# start: start  zend + zentracker
# stop : stop   zend + zentracker
# restart: stop + (?wait?) + start
# chal/challenge: request challenge
# configure/cfg: set up for type/region/stake
# info: extract addresses, balances, keys for backup & scripting
# status: services up/down, exception if any, challenge balance
"
  printf 'Usage: %s [-w|--(no-)wait] [-h|--help] [-v|--version] <verb> [<parms-1>] ... [<parms-n>] ...\n' "$0"
  printf '\t%s\n' "<verb>: Script action: start,stop,restart,chal/challenge,cfg/configure,info,status"
  printf '\t%s\n' "<parms>: Additional parameters for configure"
  printf '\t%s\n' "-w,--wait,--no-wait: Wait for requested operation to complete (off by default)"
  printf '\t%s\n' "-h,--help: Prints help"
  printf '\t%s\n' "-v,--version: Prints version"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -w|--no-wait|--wait)
        _arg_wait="on"
        test "${1:0:5}" = "--no-" && _arg_wait="off"
        ;;
      -w*)
        _arg_wait="on"
        _next="${_key##-w}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-w" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        echo $0 v0.1
        exit 0
        ;;
      -v*)
        echo $0 v0.1
        exit 0
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'verb'"
  test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_verb' )
  _our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
  for ((ii = 0; ii < _our_args; ii++))
  do
    _positional_names+=("_arg_parms[$((ii + 0))]")
  done

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#zen_home=/home/zen
zen_home=.
tracker_dir=$zen_home/secnodetracker

function challenge() {
  started_at=$(date "+%Y-%m-%d %H:%M:%S")

  chal_check=$(date -d 'now - 1 minute' "+%Y-%m-%d %H:%M:%S")
  if journalctl -u zentracker --since "$chal_check" | grep "[Cc]hallenge"; then
    echo Challenge already running or recently completed
    # todo: See if failed, then allow run
    exit 0
  fi

  tracker_home=$(jq -r '.secure.home | sub("ts1|ts"; "")' "$tracker_dir/config/config.json") 
  tracker_host=securenodes$tracker_home.zensystem.io
  chal_addr=$(zen-cli listaddresses | jq -r '.[0]')
  node_id=$(jq -r '.secure.nodeid' "$tracker_dir/config/config.json") 
  chal_url=https://$tracker_host/$chal_addr/$node_id/send
  echo Requesting challenge via $chal_url
  curl -O $chal_url
  if [ $_arg_wait == on ]; then
    echo Waiting for challenge to run...
    for delay in  {1..60}; do
      sleep 1
      if journalctl -u zentracker --since "$started_at" -q | grep "Challenge result"; then
        break
      fi
      let "remainder = delay % 10"
      if [ "$remainder" -eq 0 ]; then 
        journalctl -n 1 -u zentracker -q
      fi
    done
    echo "Done waiting for challenge!"
  fi
}

function stop() {
  sudo systemctl stop zentracker zend
  if [ $_arg_wait == on ]; then  
    echo Waiting for zend to stop...
    for delay in  {1..60}; do
      if journalctl -u zend | grep "Shutdown: done"; then
        break
      fi
      sleep 1
    done
    echo zend stopped!
  fi
}

#todo: wait for tracker rather than zend
function start() {
  sudo systemctl start zend zentracker
  if [ $_arg_wait == "on" ]; then  
#    for delay in  {1..60}; do
#      if [ $(zen-cli | jq -r '.connections') -eq 8 ] ; then
#        break
#      else
#        sleep 1
#      fi
#    done
    echo zend started!
  fi
}

function status() {
  echo not yet implemented
}

function info() {
  echo not yet implemented
}

function configure() {
  # coalesce node type from parameter, existing config, default
  # preload a secnodetracker/config/default.json that's part of machine build
  base_config_file=$tracker_dir/config/config.json
  new_config_file=$tracker_dir/config/new-config.json
  old_config_file=$tracker_dir/config/old-config.json
  default_config_file=$tracker_dir/config/default-config.json

  if [ ! -f $base_config_file ]; then
    cp $default_config_file $base_config_file
  fi

  nodetype=$(jq -r '.nodetype' <(echo $_arg_parms))
  if [ $nodetype == null ]; then
    # echo Node type not specified in input block, fetching from current config
    # echo $base_config
    nodetype=$(jq -r '.active' $base_config_file)
  fi

  if [[ ! $nodetype =~ ^(super|secure)$ ]]; then
    echo Invalid node type $nodetype
    exit 1
  fi
  #echo got nodetype $nodetype

  current_config=$(jq '.[.active]' $base_config_file)
  #new_config=$({active:$nodetype,$nodetype:$parms')
#  echo "$current_config"
#  echo "$_arg_parms"
  parm_config=$(jq '.'  <(echo $_arg_parms))
#  jq -n --argjson cfg "$current_config" '$cfg'
#  jq -n --argjson cfg "$new_config" '$cfg'
  # merge old config to new config
  api_server=$(jq -r --arg nodetype "$nodetype" '.servers[$nodetype]' $tracker_dir/init.json)
#  jq -r ".$nodetype" $tracker_dir/init.json

  new_config=$(jq -n --argjson cur_cfg "$current_config" --argjson parm_cfg "$parm_config" '$cur_cfg * $parm_cfg')
  region=$(jq -n -r --argjson new_cfg "$new_config" '$new_cfg.region')
#  curl -L $api_server | jq --arg region "$region" '{servers:.servers,home:.servers[] | select(endswith("$region") | first)}'
#  exit

  servers=$(curl -sL $api_server | jq '{servers:.servers}')
  home=$(jq -n --arg rgn "$region" --argjson srvs "$servers" '{home:[$srvs.servers[] | select(endswith($rgn))] | first}')
  merged_config=$(jq -n --argjson cfg "$new_config" --argjson srvs "$servers"  --argjson hme "$home" '$cfg * $srvs * $hme')
  jq --argjson cfg "$merged_config" --arg ntyp "$nodetype" '. * {active:$ntyp,($ntyp):$cfg}' $base_config_file > $new_config_file

  changed=$(jq -s '.[0] == .[0]' $base_config_file $new_config_file)

  if [ $changed == 'true' ]; then
    mv $base_config_file $old_config_file
    mv $new_config_file $base_config_file
    sudo systemctl zentracker restart
  fi
  jq . $base_config_file

}

function cfg() {
  configure
}

function restart() {
  stop
  start
}

function chal() {
  challenge
}

# todo: convert verbs into array?
if [[ $_arg_verb =~ ^(stop|start|restart|challenge|chal|configure|cfg|status|info)$ ]]; then
  # run function corresponding to script action verb
  $_arg_verb
  exit 0
else
  echo "Action required: stop | start | restart | chal|challenge | cfg|configure | status | info"
  exit 1
fi

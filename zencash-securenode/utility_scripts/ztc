#!/usr/bin/env bash
#
# Argbash definitions for ZenCash Tracker control script ztc
#
# ARG_OPTIONAL_BOOLEAN([wait],[w],[Wait for requested operation to complete])
# ARG_POSITIONAL_SINGLE([verb],[Script action: start,stop,restart,chal/challenge,cfg/configure,info,status],[])
# ARG_POSITIONAL_INF([parms],[Additional parameters for configure],[])
# ARG_HELP([ZenCash Tracker control script ztc
# -w, --wait to follow log until completion
# start: start  zend + zentracker
# stop : stop   zend + zentracker
# restart: stop + (?wait?) + start
# chal/challenge: request challenge
# configure/cfg: set up for type/region/stake
# info: extract addresses, balances, keys for backup & scripting
# status: services up/down, exception if any, challenge balance
# ])
# ARG_VERSION([echo $0 v0.1])
# ARGBASH_SET_INDENT([  ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}

begins_with_short_option()
{
  local first_option all_short_options
  all_short_options='whv'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_parms=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_wait="off"

print_help ()
{
  printf '%s\n' "ZenCash Tracker control script ztc
# -w, --wait to follow log until completion
# start: start  zend + zentracker
# stop : stop   zend + zentracker
# restart: stop + (?wait?) + start
# chal/challenge: request challenge
# configure/cfg: set up for type/region/stake
# info: extract addresses, balances, keys for backup & scripting
# status: services up/down, exception if any, challenge balance
# eol: end of life node - change to dead end email address, remove stake balance, disable tracker service
"
  printf 'Usage: %s [-w|--(no-)wait] [-h|--help] [-v|--version] <verb> [<parms-1>] ... [<parms-n>] ...\n' "$0"
  printf '\t%s\n' "<verb>: Script action: start,stop,restart,chal/challenge,cfg/configure,info,status,eol"
  printf '\t%s\n' "<parms>: Additional parameters for configure"
  printf '\t%s\n' "-w,--wait,--no-wait: Wait for requested operation to complete (off by default)"
  printf '\t%s\n' "-h,--help: Prints help"
  printf '\t%s\n' "-v,--version: Prints version"
}

parse_commandline ()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -w|--no-wait|--wait)
        _arg_wait="on"
        test "${1:0:5}" = "--no-" && _arg_wait="off"
        ;;
      -w*)
        _arg_wait="on"
        _next="${_key##-w}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          begins_with_short_option "$_next" && shift && set -- "-w" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      -v|--version)
        echo $0 v0.1
        exit 0
        ;;
      -v*)
        echo $0 v0.1
        exit 0
        ;;
      *)
        _positionals+=("$1")
        ;;
    esac
    shift
  done
}


handle_passed_args_count ()
{
  _required_args_string="'verb'"
  test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require at least 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
}

assign_positional_args ()
{
  _positional_names=('_arg_verb' )
  _our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
  for ((ii = 0; ii < _our_args; ii++))
  do
    _positional_names+=("_arg_parms[$((ii + 0))]")
  done

  for (( ii = 0; ii < ${#_positionals[@]}; ii++))
  do
    eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
  done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#zen_home=.
zen_home=/home/zen
tracker_dir=$zen_home/secnodetracker

journal_wait() {
    wait_date=$(date +"%F %X")
    echo "Waiting for $1 to $2..."
    for delay in  {1..120}; do
        journalctl -u $1 -q -S "-1s" --no-pager
        log_check=$(journalctl -u $1 -S "$wait_date" --no-pager -o cat | grep "$3")
        if [ -n "$log_check" ]; then
            break
        fi
        sleep 1
    done
}

function challenge() {
  started_at=$(date "+%Y-%m-%d %H:%M:%S")

  chal_check=$(date -d 'now - 1 minute' "+%Y-%m-%d %H:%M:%S")
  if journalctl -u zentracker --since "$chal_check" | grep "[Cc]hallenge"; then
    echo Challenge already running or recently completed
    # todo: See if failed, then allow run
    exit 0
  fi

  nodetype=$(jq -r '.active' "$tracker_dir/config/config.json")
  tracker_home=$(jq -r --arg nodetype $nodetype '.[$nodetype].home' "$tracker_dir/config/config.json")
  tracker_hostname=$(echo "$tracker_home" | sed s/ts1/ts/ | sed s/ts/securenodes/ | sed s/xns/supernodes/)
  chal_addr=$(zen-cli listaddresses | jq -r '.[0]')
  node_id=$(jq -r --arg nodetype $nodetype '.[$nodetype].nodeid' "$tracker_dir/config/config.json")
  chal_url=https://$tracker_hostname.zensystem.io/$chal_addr/$node_id/send
  echo Requesting challenge via $chal_url
  curl -O $chal_url
  if [ $_arg_wait == on ]; then
    echo Waiting for challenge to run...
    for delay in  {1..60}; do
      sleep 1
      if journalctl -u zentracker --since "$started_at" -q | grep "Challenge result"; then
        break
      fi
      let "remainder = delay % 10"
      if [ "$remainder" -eq 0 ]; then
        journalctl -n 1 -u zentracker -q
      fi
    done
    echo "Done waiting for challenge!"
  fi
}

function stop() {
  sudo systemctl stop zentracker zend
  if [ $_arg_wait == on ]; then
    echo Waiting for zend to stop...
    for delay in  {1..60}; do
      if journalctl -u zend | grep "Shutdown: done"; then
        break
      fi
      sleep 1
    done
    echo zend stopped!
  fi
}

#todo: wait for tracker rather than zend
function start() {

  if systemctl is-active --quiet zentracker; then
    exit
  fi

  sudo systemctl start zentracker

  if [ $_arg_wait == "on" ]; then
    journal_wait zentracker start "Stats received"
    echo zend started!
  fi
}

function status() {
  echo not yet implemented
}

function info() {
  echo not yet implemented
}

function configure() {
  # coalesce node type from parameter, existing config, default
  # preload a secnodetracker/config/default.json that's part of machine build
  base_config_file=$tracker_dir/config/config.json
  new_config_file=$tracker_dir/config/new-config.json
  old_config_file=$tracker_dir/config/old-config.json
  default_config_file=$tracker_dir/config/default-config.json

  if [ ! -f $base_config_file ]; then
    cp $default_config_file $base_config_file
  fi

  nodetype=$(jq -r '.nodetype' <(echo $_arg_parms))

  if [ -z "$nodetype" ]; then
    # echo Node type not specified in input block, fetching from current config
    # echo $base_config
    nodetype=$(jq -r '.active' $base_config_file)
  fi

  if [[ ! $nodetype =~ ^(super|secure)$ ]]; then
    echo Invalid node type $nodetype
    exit 1
  fi
  #echo got nodetype $nodetype

  current_config=$(jq '.[.active]' $base_config_file)
  #new_config=$({active:$nodetype,$nodetype:$parms')
#  echo "$current_config"
#  echo "$_arg_parms"
  parm_config=$(jq '.'  <(echo $_arg_parms))
#  jq -n --argjson cfg "$current_config" '$cfg'
#  jq -n --argjson cfg "$new_config" '$cfg'
  # merge old config to new config
  api_server=$(jq -r --arg nodetype "$nodetype" '.servers[$nodetype]' $tracker_dir/init.json)
#  jq -r ".$nodetype" $tracker_dir/init.json

  new_config=$(jq -n --argjson cur_cfg "$current_config" --argjson parm_cfg "$parm_config" '$cur_cfg * $parm_cfg')
  region=$(jq -n -r --argjson new_cfg "$new_config" '$new_cfg.region')
#  curl -L $api_server | jq --arg region "$region" '{servers:.servers,home:.servers[] | select(endswith("$region") | first)}'
#  exit

  servers=$(curl -sL $api_server | jq '{servers:.servers}')
  home=$(jq -n --arg rgn "$region" --argjson srvs "$servers" '{home:[$srvs.servers[] | select(endswith($rgn))] | first}')
  merged_config=$(jq -n --argjson cfg "$new_config" --argjson srvs "$servers"  --argjson hme "$home" '$cfg * $srvs * $hme')
  jq --argjson cfg "$merged_config" --arg ntyp "$nodetype" '. * {active:$ntyp,($ntyp):$cfg}' $base_config_file > $new_config_file

  changed=$(jq -s '.[0] == .[0]' $base_config_file $new_config_file)

  if [ $changed == 'true' ]; then
    mv $base_config_file $old_config_file
    mv $new_config_file $base_config_file
    sudo systemctl restart zentracker
  fi
  jq . $base_config_file

}

function cfg() {
  configure
}

function restart() {
  stop
  start
}

function chal() {
  challenge
}

function balances() {
  if [ "$USER" != "zen" ]; then
    suzen="sudo -iu zen"
  else
    suzen=""
  fi

  addr_bals='[]'
  for addr in $($suzen zen-cli z_listaddresses | jq -r '.[]'); do
    bal=$($suzen zen-cli z_getbalance $addr)
    # addr_bals=$(echo $addr_bals | jq -c --arg a $addr --arg b $bal '. + [{address: $a, balance: $b | tonumber}]');
    addr_bals=$(jq -nc --argjson j $addr_bals --arg a $addr --arg b $bal '$j + [{address: $a, balance: $b | tonumber}]')
  done;

  echo $addr_bals | jq -r '. | sort_by(.balance) | reverse'
}

function pull() {

src="${_arg_parms[0]}"

if [ -z "$src" ]; then
  echo Source is required
  exit 1
fi

if [[ $src =~ ^(.*)@ ]]; then
  src_user=${BASH_REMATCH[1]}
else
  src_user='zen'
fi

if [[ $src =~ :(.*)$ ]]; then
  src_path=${BASH_REMATCH[1]}
else
  src_path='.'
fi

[[ "@$src:" =~ @([^@:]*): ]] && src_host=${BASH_REMATCH[1]}

# make working directory
tmp_dir=$(mktemp -d)

echo copy wallet from source
ssh -o StrictHostKeyChecking=accept-new $src_user@$src_host zen-cli listaddresses > $tmp_dir/listaddresses
scp -o StrictHostKeyChecking=accept-new $src_user@$src_host:$src_path/.zen/wallet.dat $tmp_dir/
if [ $? -ne 0 ]; then
    echo "Couldn't get wallet data file!"
    exit
fi

echo copy config files from source
stop_tracker="sudo systemctl stop zentracker" # && sudo systemctl disable zentracker"
scp $src_user@$src_host:$src_path/secnodetracker/config/config.json $tmp_dir/
if [ $? -ne 0 ]; then
    stop_tracker="pm2 stop 0" # && pm2 delete 0 ??? or pm2 unstartup ???
    scp $src_user@$src_host:$src_path/secnodetracker/config/{nodeid,stakeaddr} $tmp_dir/
fi
if [ $? -ne 0 ]; then
    echo "Couldn't get config file(s)!"
    exit
fi

# chmod the working directory and files so the zen user can read them
chmod -R 0755 $tmp_dir

# run unprivileged user portion of script as zen user
# realpath, or move to /usr/local/bin?

if (sudo -iu $src_user ztc pull_user $tmp_dir); then
    echo stop tracker on source server
    ssh $src_user@$src_host "$stop_tracker"
    # rename or baseline the config on the source to be sure it doesn't restart and jerk the node back?

    # for whatever strange reason seems we need to restart zentracker 2x
    # so we do it again after stopping tracker on source node
    sudo systemctl restart zentracker
    journal_wait zentracker start " Authenticated"
fi

}

function pull_user() {

tmp_dir="${_arg_parms[0]}"

if [ -z $tmp_dir ]; then
  echo Working directory is required
  exit 1
fi

# tracker_dir=secnodetracker

echo stop local services
sudo systemctl stop zentracker
if (systemctl -q is-active zend); then
  sudo systemctl stop zend
  journal_wait zend stop "Stopped ZenCash daemon"
  # See if we can mitigate stupid hang behavior
  sleep 2
fi

echo back up local wallet and config
backup_dir="zen-backup/$(date +%s)"
mkdir -p $backup_dir
cp {.zen/wallet.dat,secnodetracker/config/config.json} $backup_dir/

echo copy wallet from source
cp --no-preserve owner,mode $tmp_dir/wallet.dat .zen/
if [ $? -ne 0 ]; then
    echo "Couldn't get wallet data file!"
    exit 1
fi

echo start zend
sudo systemctl restart zend

echo wait for zend to finish restart/rescan
journal_wait zend start "init message: Done loading"

# check zend first address against source
t_addr=$(zen-cli listaddresses | jq -r .[0])
echo $t_addr
src_t_addr=$(jq -r .[0] $tmp_dir/listaddresses)
if [ $t_addr != $src_t_addr ]; then
    echo "T Address doesn't match source!"
    exit 1
fi

echo check that we have a challenge balance
z_bal=$(zen-cli z_gettotalbalance | jq -r .private)
if [ $z_bal == "0.00" ]; then
   echo "Challenge balance is zero!"
   exit 1
fi

echo get node details
if [ -f $tmp_dir/config.json ]; then
    node_type=$(jq -r .active $tmp_dir/config.json)
    node_id=$(jq --arg nodetype "$node_type" -r '.[$nodetype].nodeid' $tmp_dir/config.json)
    stake_addr=$(jq --arg nodetype "$node_type" -r '.[$nodetype].stakeaddr' $tmp_dir/config.json)
    tracker_stop="sudo systemctl stop zentracker"
else
    node_type=secure
    node_id=$(cat $tmp_dir/nodeid)
    stake_addr=$(cat $tmp_dir/stakeaddr)
    tracker_stop="pm2 stop 0"
fi

echo get servers from zen
api_server=$(jq -r --arg nodetype "$node_type" '.servers[$nodetype]' $tracker_dir/init.json)
servers=$(curl -sL $api_server | jq '.servers')
region=$(jq -r --arg nodetype "$node_type" '.[$nodetype].region' $tracker_dir/config/config.json)
home=$(jq -r -n --arg rgn "$region" --argjson srvs "$servers" '[$srvs[] | select(endswith($rgn))] | first')

echo write node details to config.json
tmp_cfg=$(mktemp)
jq --arg ntyp "$node_type" --arg nid "$node_id" --arg stk "$stake_addr" --arg hom "$home" \
   '.active=$ntyp | .[$ntyp].nodeid=$nid | .[$ntyp].stakeaddr=$stk | .[$ntyp].home=$hom | .' \
   $tracker_dir/config/config.json > "$tmp_cfg"
mv "$tmp_cfg" $tracker_dir/config/config.json

echo start zentracker
sudo systemctl start zentracker

echo wait for tracker to authenticate
journal_wait zentracker start " Authenticated"

# verify that we see an IP changed?

}

function destake() {

    toaddr=znVFYD4QWsRUMbgEPcVz3MXvHvEB4U4K6FL

    node_bals=$(zbals | jq -cr '.[]')

    for addr_bal in $node_bals; do
      addr=$(jq -r -n --argjson j "$addr_bal" '$j.address')
      bal=$(jq -r -n --argjson j "$addr_bal" '$j.balance')
      amt=$(python -c "print($bal-0.0001 if $bal > 0.0001 else '')")
      #amt=$(python -c "print($bal-0.01 if $bal > 0.011 else '')")
      if [ -n "$amt" ]; then
        #  read -p "Send $amt ZEN from $addr to $toaddr? (y/n) " -n 1 -r
        echo "Sending $amt ZEN from $addr to $toaddr"
        echo # (optional) move to a new line
        #  if [[ $REPLY =~ ^[Yy]$ ]]; then
        zen-cli z_sendmany $addr '[{"address": "'"$toaddr"'", "amount":'"$amt"'}]'
        #  fi
      fi
    done

    for delay in  {1..300}; do
      sleep 1
      #zen-cli z_getoperationstatus | jq -r .[].status
      #zen-cli z_getoperationstatus | jq -r '[ .[] | select(.status == "executing") ] | length'

      if [ "$(zen-cli z_getoperationstatus | jq -r '[ .[] | select(.status == "executing") ] | length')" -eq 0 ]; then
        echo $delay
        zen-cli z_getoperationstatus | jq -r .[].status
        break
      fi
      let "remainder = delay % 10"
      if [ "$remainder" -eq 0 ]; then
        echo $delay
        zen-cli z_getoperationstatus | jq -r .[].status
      fi
    done
    echo "Done waiting for destake send"

}

function eol() {
    cfg=~/secnodetracker/config/config.json
    eol_date=$(date "+%Y-%m-%d")

    if [[ "$(jq .secure.nodeid $cfg)" != null ]]; then
        mv $cfg $cfg.eol.$eol_date
        jq '.secure.email="eol@4nl.co"' $cfg.eol.$eol_date > $cfg
        sudo systemctl restart zentracker
        # wait for restart so email gets updated on server side
        journal_wait zentracker update "Email changed to eol@4nl.co"
        # belt n suspenders
        sleep 2
        sudo systemctl stop zentracker
        sudo systemctl disable zentracker

        jq 'del(.secure.nodeid,.secure.stakeaddr)' $cfg.eol.$eol_date > $cfg

        destake

        sudo systemctl stop zend
        # wait for service to stop & close wallet
        journal_wait zend stop "Stopped ZenCash daemon"
        # belt n suspenders
        sleep 2
        mkdir -p ~/.zen/backup
        mv ~/.zen/wallet.dat ~/.zen/backup/wallet.dat.eol.$eol_date
        # restart zend with no wallet to auto-create new one
        sudo systemctl start zend
    fi
}

# remember this must be at the end of the script so all functions are available
# todo: convert verbs into array?
if [[ $_arg_verb =~ ^(stop|start|restart|challenge|chal|configure|cfg|status|info|balances|pull|pull_user|eol)$ ]]; then
  # run function corresponding to script action verb
  $_arg_verb
  exit 0
else
  echo "Action required: stop | start | restart | chal|challenge | cfg|configure | status | info | balances | pull | eol"
  exit 1
fi

